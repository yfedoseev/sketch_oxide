/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Result of weighted cardinality estimation */
export interface WeightedCardinalityResult {
  /** The estimated weighted cardinality */
  estimate: number
  /** The error bound (95% confidence interval radius) */
  errorBound: number
}
/** Result object for Space-Saving heavy hitter queries */
export interface HeavyHitterResult {
  key: string
  lowerBound: number
  upperBound: number
}
/** Error type for frequent items queries */
export const enum FrequentItemsErrorType {
  NoFalsePositives = 0,
  NoFalseNegatives = 1
}
/** Result object for FrequentItems queries */
export interface FrequentItemResult {
  key: string
  lowerBound: number
  upperBound: number
}
/** REQ Sketch mode */
export const enum ReqSketchMode {
  HighRankAccuracy = 0,
  LowRankAccuracy = 1
}
/** Weighted item in a VarOpt sample */
export interface WeightedSampleItem {
  item: Buffer
  weight: number
  adjustedWeight: number
}
/** Count estimate with bounds */
export interface CountWithBounds {
  estimate: bigint
  lower: bigint
  upper: bigint
}
/** Heavy hitter result */
export interface HeavyHitter {
  itemHash: bigint
  frequency: bigint
}
/** Estimate result with confidence */
export interface EstimateWithConfidence {
  estimate: bigint
  confidence: bigint
}
export interface HeavyKeeperResult {
  hash: bigint
  count: number
}
export interface IbltDecodeResult {
  toInsert: Array<KeyValuePair>
  toRemove: Array<KeyValuePair>
  success: boolean
}
export interface KeyValuePair {
  key: Buffer
  value: Buffer
}
export interface GrafiteStats {
  keyCount: number
  bitsPerKey: number
  totalBits: number
}
export interface VacuumFilterStats {
  capacity: number
  numItems: number
  loadFactor: number
  memoryBits: number
  fingerprintBits: number
}
export interface GrfStats {
  keyCount: number
  segmentCount: number
  avgKeysPerSegment: number
  bitsPerKey: number
  totalBits: number
  memoryBytes: number
}
export interface NitroSketchStats {
  sampleRate: number
  sampledCount: number
  unsampledCount: number
  totalItemsEstimated: number
}
/**
 * HyperLogLog cardinality estimator
 *
 * Provides ~1.04/sqrt(m) standard error where m = 2^precision
 *
 * # Example
 * ```javascript
 * const { HyperLogLog } = require('@sketch-oxide/node');
 * const hll = new HyperLogLog(14);
 * hll.update(Buffer.from('item1'));
 * hll.update(Buffer.from('item2'));
 * console.log(hll.estimate()); // ~2
 * ```
 */
export declare class HyperLogLog {
  /**
   * Create a new HyperLogLog with given precision
   *
   * # Arguments
   * * `precision` - Number of bits for the hash (4-16 recommended, typical 12-14)
   *
   * # Returns
   * A new HyperLogLog instance
   *
   * # Throws
   * - If precision is out of valid range (4-16)
   *
   * # Example
   * ```javascript
   * const hll = new HyperLogLog(14);
   * ```
   */
  constructor(precision: number)
  /**
   * Add an item to the sketch
   *
   * # Arguments
   * * `item` - Binary data to add
   *
   * # Example
   * ```javascript
   * hll.update(Buffer.from('item1'));
   * hll.update(Buffer.from('hello world'));
   * ```
   */
  update(item: Buffer): void
  /**
   * Get current cardinality estimate
   *
   * # Returns
   * Estimated number of unique items
   *
   * # Example
   * ```javascript
   * const estimate = hll.estimate();
   * console.log(estimate); // e.g., 1000000
   * ```
   */
  estimate(): number
  /**
   * Merge another HyperLogLog sketch into this one
   *
   * # Arguments
   * * `other` - Another HyperLogLog with same precision
   *
   * # Throws
   * - If precisions don't match
   *
   * # Example
   * ```javascript
   * const hll1 = new HyperLogLog(14);
   * const hll2 = new HyperLogLog(14);
   * hll1.update(Buffer.from('a'));
   * hll2.update(Buffer.from('b'));
   * hll1.merge(hll2);
   * console.log(hll1.estimate()); // ~2
   * ```
   */
  merge(other: HyperLogLog): void
  /**
   * Create a new sketch instance (reset)
   * Note: In Rust, we create a new instance instead of resetting
   * Use `new HyperLogLog(precision)` instead
   * Keeping this method for API compatibility
   */
  reset(): void
  /**
   * Get the precision level
   *
   * # Example
   * ```javascript
   * const hll = new HyperLogLog(14);
   * console.log(hll.precision()); // 14
   * ```
   */
  precision(): number
  /**
   * Serialize the sketch to binary format
   *
   * # Returns
   * Binary representation suitable for storage/transmission
   *
   * # Example
   * ```javascript
   * const data = hll.serialize();
   * fs.writeFileSync('hll.bin', data);
   * ```
   */
  serialize(): Buffer
  /**
   * Deserialize from binary format
   *
   * # Arguments
   * * `data` - Binary data from serialize()
   *
   * # Example
   * ```javascript
   * const data = fs.readFileSync('hll.bin');
   * const hll = HyperLogLog.deserialize(data);
   * ```
   */
  static deserialize(data: Buffer): HyperLogLog
  /**
   * Get string representation
   *
   * # Example
   * ```javascript
   * console.log(hll.toString());
   * // "HyperLogLog(precision=14, estimate=1000000)"
   * ```
   */
  toString(): string
}
/**
 * UltraLogLog cardinality estimator - 28% more space-efficient than HyperLogLog
 *
 * UltraLogLog is a state-of-the-art algorithm from VLDB 2024 that provides
 * the same accuracy as HyperLogLog while using 28% less memory.
 *
 * # Example
 * ```javascript
 * const { UltraLogLog } = require('@sketch-oxide/node');
 * const ull = new UltraLogLog(12);
 * ull.update(Buffer.from('item1'));
 * ull.update(Buffer.from('item2'));
 * console.log(ull.estimate()); // ~2
 * ```
 */
export declare class UltraLogLog {
  /**
   * Create a new UltraLogLog with given precision
   *
   * # Arguments
   * * `precision` - Number of bits for the hash (4-18, typical 12-14)
   *   - precision 4: 16 registers, 16 bytes
   *   - precision 8: 256 registers, 256 bytes
   *   - precision 12: 4096 registers, 4 KB (recommended)
   *   - precision 16: 65536 registers, 64 KB
   *   - precision 18: 262144 registers, 256 KB
   *
   * # Returns
   * A new UltraLogLog instance
   *
   * # Throws
   * - If precision is out of valid range (4-18)
   *
   * # Example
   * ```javascript
   * const ull = new UltraLogLog(12);
   * ```
   */
  constructor(precision: number)
  /**
   * Add an item to the sketch
   *
   * # Arguments
   * * `item` - Binary data to add
   *
   * # Example
   * ```javascript
   * ull.update(Buffer.from('item1'));
   * ull.update(Buffer.from('hello world'));
   * ```
   */
  update(item: Buffer): void
  /**
   * Get current cardinality estimate
   *
   * # Returns
   * Estimated number of unique items
   *
   * # Example
   * ```javascript
   * const estimate = ull.estimate();
   * console.log(estimate); // e.g., 1000000
   * ```
   */
  estimate(): number
  /**
   * Get the cardinality estimate (alias for estimate)
   *
   * # Returns
   * Estimated number of unique items
   *
   * # Example
   * ```javascript
   * const cardinality = ull.cardinality();
   * ```
   */
  cardinality(): number
  /**
   * Merge another UltraLogLog sketch into this one
   *
   * # Arguments
   * * `other` - Another UltraLogLog with same precision
   *
   * # Throws
   * - If precisions don't match
   *
   * # Example
   * ```javascript
   * const ull1 = new UltraLogLog(12);
   * const ull2 = new UltraLogLog(12);
   * ull1.update(Buffer.from('a'));
   * ull2.update(Buffer.from('b'));
   * ull1.merge(ull2);
   * console.log(ull1.estimate()); // ~2
   * ```
   */
  merge(other: UltraLogLog): void
  /**
   * Check if the sketch is empty (no items added)
   *
   * # Returns
   * True if no items have been added
   *
   * # Example
   * ```javascript
   * const ull = new UltraLogLog(12);
   * console.log(ull.isEmpty()); // true
   * ull.update(Buffer.from('item'));
   * console.log(ull.isEmpty()); // false
   * ```
   */
  isEmpty(): boolean
  /**
   * Serialize the sketch to binary format
   *
   * # Returns
   * Binary representation suitable for storage/transmission
   *
   * # Example
   * ```javascript
   * const data = ull.serialize();
   * fs.writeFileSync('ull.bin', data);
   * ```
   */
  serialize(): Buffer
  /**
   * Deserialize from binary format
   *
   * # Arguments
   * * `data` - Binary data from serialize()
   *
   * # Returns
   * A new UltraLogLog instance
   *
   * # Throws
   * - If data is invalid or corrupted
   *
   * # Example
   * ```javascript
   * const data = fs.readFileSync('ull.bin');
   * const ull = UltraLogLog.deserialize(data);
   * ```
   */
  static deserialize(data: Buffer): UltraLogLog
  /**
   * Get string representation
   *
   * # Example
   * ```javascript
   * console.log(ull.toString());
   * // "UltraLogLog(estimate=1000000)"
   * ```
   */
  toString(): string
}
/**
 * CPC (Compressed Probabilistic Counting) Sketch
 *
 * CPC is 30-40% more space-efficient than HyperLogLog for the same accuracy.
 * It achieves this through adaptive compression and multiple operational modes.
 *
 * # Example
 * ```javascript
 * const { CpcSketch } = require('@sketch-oxide/node');
 * const cpc = new CpcSketch(11);
 * cpc.update(Buffer.from('item1'));
 * cpc.update(Buffer.from('item2'));
 * console.log(cpc.estimate()); // ~2
 * ```
 */
export declare class CpcSketch {
  /**
   * Create a new CPC sketch with given lg_k parameter
   *
   * # Arguments
   * * `lgK` - Log2 of k parameter (4-26), higher = more accurate but more memory
   *   - lgK 4: k=16, very high error (~20%)
   *   - lgK 8: k=256, ~6% error
   *   - lgK 11: k=2048, ~2% error (recommended default)
   *   - lgK 12: k=4096, ~1.5% error
   *   - lgK 16: k=65536, ~0.4% error
   *
   * # Returns
   * A new CpcSketch instance
   *
   * # Throws
   * - If lgK is out of valid range (4-26)
   *
   * # Example
   * ```javascript
   * const cpc = new CpcSketch(11);
   * ```
   */
  constructor(lgK: number)
  /**
   * Add an item to the sketch
   *
   * # Arguments
   * * `item` - Binary data to add
   *
   * # Example
   * ```javascript
   * cpc.update(Buffer.from('item1'));
   * cpc.update(Buffer.from('hello world'));
   * ```
   */
  update(item: Buffer): void
  /**
   * Get current cardinality estimate
   *
   * # Returns
   * Estimated number of unique items
   *
   * # Example
   * ```javascript
   * const estimate = cpc.estimate();
   * console.log(estimate); // e.g., 1000000
   * ```
   */
  estimate(): number
  /**
   * Get the lg_k parameter
   *
   * # Returns
   * The lg_k value used to create this sketch
   *
   * # Example
   * ```javascript
   * const cpc = new CpcSketch(11);
   * console.log(cpc.lgK()); // 11
   * ```
   */
  lgK(): number
  /**
   * Get the current operational flavor/mode
   *
   * CPC uses different representations as cardinality grows:
   * - Empty: No items observed
   * - Sparse: Few items, space-efficient
   * - Hybrid: Transitioning
   * - Pinned: Dense uncompressed
   * - Sliding: Dense compressed (maximum efficiency)
   *
   * # Returns
   * String describing the current mode
   *
   * # Example
   * ```javascript
   * console.log(cpc.flavor()); // "Sparse"
   * ```
   */
  flavor(): string
  /**
   * Clear the sketch to empty state
   *
   * # Example
   * ```javascript
   * cpc.clear();
   * console.log(cpc.isEmpty()); // true
   * ```
   */
  clear(): void
  /**
   * Check if the sketch is empty
   *
   * # Returns
   * True if no items have been added
   *
   * # Example
   * ```javascript
   * const cpc = new CpcSketch(11);
   * console.log(cpc.isEmpty()); // true
   * ```
   */
  isEmpty(): boolean
  /**
   * Get the approximate size in bytes
   *
   * # Returns
   * Approximate memory usage in bytes
   *
   * # Example
   * ```javascript
   * console.log(cpc.sizeBytes()); // e.g., 1024
   * ```
   */
  sizeBytes(): number
  /**
   * Merge another CpcSketch into this one
   *
   * # Arguments
   * * `other` - Another CpcSketch with same lg_k
   *
   * # Throws
   * - If lg_k values don't match
   *
   * # Example
   * ```javascript
   * const cpc1 = new CpcSketch(11);
   * const cpc2 = new CpcSketch(11);
   * cpc1.update(Buffer.from('a'));
   * cpc2.update(Buffer.from('b'));
   * cpc1.merge(cpc2);
   * console.log(cpc1.estimate()); // ~2
   * ```
   */
  merge(other: CpcSketch): void
  /**
   * Serialize the sketch to binary format
   *
   * # Returns
   * Binary representation suitable for storage/transmission
   *
   * # Example
   * ```javascript
   * const data = cpc.serialize();
   * fs.writeFileSync('cpc.bin', data);
   * ```
   */
  serialize(): Buffer
  /**
   * Deserialize from binary format
   *
   * # Arguments
   * * `data` - Binary data from serialize()
   *
   * # Returns
   * A new CpcSketch instance
   *
   * # Throws
   * - If data is invalid or corrupted
   *
   * # Example
   * ```javascript
   * const data = fs.readFileSync('cpc.bin');
   * const cpc = CpcSketch.deserialize(data);
   * ```
   */
  static deserialize(data: Buffer): CpcSketch
  /**
   * Get string representation
   *
   * # Example
   * ```javascript
   * console.log(cpc.toString());
   * // "CpcSketch(lgK=11, flavor=Sparse, estimate=1000)"
   * ```
   */
  toString(): string
}
/**
 * QSketch for weighted cardinality estimation
 *
 * QSketch maintains a probabilistic sample of weighted elements to estimate
 * the cardinality of weighted sets with bounded error. Unlike standard
 * cardinality sketches that treat all items equally, QSketch accounts for
 * item weights in the cardinality estimate.
 *
 * # Example
 * ```javascript
 * const { QSketch } = require('@sketch-oxide/node');
 * const qs = new QSketch(256);
 * qs.update(Buffer.from('user1'), 100.0);
 * qs.update(Buffer.from('user2'), 250.0);
 * const [estimate, error] = qs.estimateWeightedCardinality();
 * console.log(`Weighted cardinality: ${estimate} +/- ${error}`);
 * ```
 */
export declare class QSketch {
  /**
   * Create a new QSketch with given maximum samples
   *
   * # Arguments
   * * `maxSamples` - Maximum number of samples to maintain (minimum 32)
   *
   * # Returns
   * A new QSketch instance
   *
   * # Throws
   * - If maxSamples is less than 32
   *
   * # Example
   * ```javascript
   * const qs = new QSketch(256);
   * ```
   */
  constructor(maxSamples: number)
  /**
   * Create a new QSketch with a specific seed for reproducibility
   *
   * # Arguments
   * * `maxSamples` - Maximum number of samples to maintain (minimum 32)
   * * `seed` - Random seed for reproducibility
   *
   * # Returns
   * A new QSketch instance
   *
   * # Example
   * ```javascript
   * const qs = QSketch.withSeed(256, 42n);
   * ```
   */
  static withSeed(maxSamples: number, seed: bigint): QSketch
  /**
   * Add a weighted item to the sketch
   *
   * # Arguments
   * * `item` - Binary data to add
   * * `weight` - Weight of the item (must be positive)
   *
   * # Throws
   * - If weight is not positive or not finite
   *
   * # Example
   * ```javascript
   * qs.update(Buffer.from('user_123'), 100.0);
   * qs.update(Buffer.from('user_456'), 250.0);
   * ```
   */
  update(item: Buffer, weight: number): void
  /**
   * Get the maximum number of samples this sketch can maintain
   *
   * # Returns
   * Maximum sample count
   *
   * # Example
   * ```javascript
   * const qs = new QSketch(256);
   * console.log(qs.maxSamples()); // 256
   * ```
   */
  maxSamples(): number
  /**
   * Get the current number of samples in the sketch
   *
   * # Returns
   * Current sample count
   *
   * # Example
   * ```javascript
   * console.log(qs.sampleCount()); // e.g., 150
   * ```
   */
  sampleCount(): number
  /**
   * Get the sum of all weights added to the sketch
   *
   * # Returns
   * Total weight of all items
   *
   * # Example
   * ```javascript
   * qs.update(Buffer.from('item1'), 10.5);
   * qs.update(Buffer.from('item2'), 20.5);
   * console.log(qs.totalWeight()); // 31.0
   * ```
   */
  totalWeight(): number
  /**
   * Get the approximate number of distinct elements
   *
   * # Returns
   * Estimated distinct element count
   *
   * # Example
   * ```javascript
   * const distinct = qs.estimateDistinctElements();
   * console.log(distinct); // e.g., 1000
   * ```
   */
  estimateDistinctElements(): number
  /**
   * Estimate the weighted cardinality with confidence bounds
   *
   * Returns an object with estimate and errorBound, where errorBound
   * represents the radius of a 95% confidence interval.
   *
   * # Returns
   * Object with { estimate: number, errorBound: number }
   *
   * # Example
   * ```javascript
   * const result = qs.estimateWeightedCardinality();
   * console.log(`Estimate: ${result.estimate} +/- ${result.errorBound}`);
   * ```
   */
  estimateWeightedCardinality(): WeightedCardinalityResult
  /**
   * Get the basic cardinality estimate (without error bounds)
   *
   * # Returns
   * Estimated cardinality
   *
   * # Example
   * ```javascript
   * const estimate = qs.estimate();
   * ```
   */
  estimate(): number
  /**
   * Check if the sketch is empty
   *
   * # Returns
   * True if no items have been added
   *
   * # Example
   * ```javascript
   * const qs = new QSketch(256);
   * console.log(qs.isEmpty()); // true
   * ```
   */
  isEmpty(): boolean
  /**
   * Reset the sketch to empty state
   *
   * # Example
   * ```javascript
   * qs.reset();
   * console.log(qs.isEmpty()); // true
   * ```
   */
  reset(): void
  /**
   * Merge another QSketch into this one
   *
   * # Arguments
   * * `other` - Another QSketch with same maxSamples
   *
   * # Throws
   * - If maxSamples values don't match
   *
   * # Example
   * ```javascript
   * const qs1 = new QSketch(256);
   * const qs2 = new QSketch(256);
   * qs1.update(Buffer.from('a'), 100.0);
   * qs2.update(Buffer.from('b'), 200.0);
   * qs1.merge(qs2);
   * ```
   */
  merge(other: QSketch): void
  /**
   * Serialize the sketch to binary format
   *
   * # Returns
   * Binary representation suitable for storage/transmission
   *
   * # Example
   * ```javascript
   * const data = qs.serialize();
   * fs.writeFileSync('qs.bin', data);
   * ```
   */
  serialize(): Buffer
  /**
   * Deserialize from binary format
   *
   * # Arguments
   * * `data` - Binary data from serialize()
   *
   * # Returns
   * A new QSketch instance
   *
   * # Throws
   * - If data is invalid or corrupted
   *
   * # Example
   * ```javascript
   * const data = fs.readFileSync('qs.bin');
   * const qs = QSketch.deserialize(data);
   * ```
   */
  static deserialize(data: Buffer): QSketch
  /**
   * Get string representation
   *
   * # Example
   * ```javascript
   * console.log(qs.toString());
   * // "QSketch(maxSamples=256, samples=150, totalWeight=1500.0)"
   * ```
   */
  toString(): string
}
/**
 * Theta Sketch for cardinality estimation with set operations
 *
 * ThetaSketch is the only sketch that supports intersection and difference
 * operations, making it ideal for computing Jaccard similarity, overlap
 * analysis, and set-based queries.
 *
 * # Example
 * ```javascript
 * const { ThetaSketch } = require('@sketch-oxide/node');
 * const sketchA = new ThetaSketch(12);
 * const sketchB = new ThetaSketch(12);
 *
 * // Add items
 * for (let i = 0; i < 100; i++) sketchA.update(Buffer.from(`item${i}`));
 * for (let i = 50; i < 150; i++) sketchB.update(Buffer.from(`item${i}`));
 *
 * // Set operations
 * const union = sketchA.union(sketchB);
 * const intersection = sketchA.intersect(sketchB);
 * const difference = sketchA.difference(sketchB);
 *
 * console.log(`Union: ${union.estimate()}`);        // ~150
 * console.log(`Intersection: ${intersection.estimate()}`); // ~50
 * console.log(`Difference: ${difference.estimate()}`);     // ~50
 * ```
 */
export declare class ThetaSketch {
  /**
   * Create a new Theta Sketch with specified lg_k
   *
   * # Arguments
   * * `lgK` - log2(k), determines accuracy and memory (4-26)
   *   - k = 2^lgK (nominal entries)
   *   - Memory: ~8k bytes
   *   - Error: ~1/sqrt(k)
   *   - lgK=12 (k=4096): ~1.6% error, 32KB (recommended)
   *   - lgK=14 (k=16384): ~0.8% error, 128KB
   *   - lgK=16 (k=65536): ~0.4% error, 512KB
   *
   * # Returns
   * A new ThetaSketch instance
   *
   * # Throws
   * - If lgK is out of valid range (4-26)
   *
   * # Example
   * ```javascript
   * const theta = new ThetaSketch(12);
   * ```
   */
  constructor(lgK: number)
  /**
   * Create a Theta Sketch with custom seed
   *
   * Use the same seed for all sketches that will be combined in set operations.
   *
   * # Arguments
   * * `lgK` - log2(k) parameter (4-26)
   * * `seed` - Custom seed for hash function
   *
   * # Returns
   * A new ThetaSketch instance
   *
   * # Example
   * ```javascript
   * const theta = ThetaSketch.withSeed(12, 12345n);
   * ```
   */
  static withSeed(lgK: number, seed: bigint): ThetaSketch
  /**
   * Add an item to the sketch
   *
   * # Arguments
   * * `item` - Binary data to add
   *
   * # Example
   * ```javascript
   * theta.update(Buffer.from('item1'));
   * theta.update(Buffer.from('hello world'));
   * ```
   */
  update(item: Buffer): void
  /**
   * Get current cardinality estimate
   *
   * # Returns
   * Estimated number of unique items
   *
   * # Example
   * ```javascript
   * const estimate = theta.estimate();
   * console.log(estimate); // e.g., 1000
   * ```
   */
  estimate(): number
  /**
   * Check if the sketch is empty
   *
   * # Returns
   * True if no items have been added
   *
   * # Example
   * ```javascript
   * const theta = new ThetaSketch(12);
   * console.log(theta.isEmpty()); // true
   * ```
   */
  isEmpty(): boolean
  /**
   * Get the number of retained hash entries
   *
   * # Returns
   * Number of hash entries currently stored
   *
   * # Example
   * ```javascript
   * console.log(theta.numRetained()); // e.g., 1000
   * ```
   */
  numRetained(): number
  /**
   * Get the current theta value
   *
   * - u64::MAX means no sampling (exact mode)
   * - Values < u64::MAX indicate sampling is active
   *
   * # Returns
   * Current theta threshold as BigInt
   *
   * # Example
   * ```javascript
   * const theta = sketch.getTheta();
   * ```
   */
  getTheta(): bigint
  /**
   * Get the nominal capacity (k = 2^lgK)
   *
   * # Returns
   * Nominal capacity
   *
   * # Example
   * ```javascript
   * const theta = new ThetaSketch(12);
   * console.log(theta.capacity()); // 4096
   * ```
   */
  capacity(): number
  /**
   * Compute union with another sketch: |A ∪ B|
   *
   * Returns a new sketch representing items in either A or B (or both).
   * Both sketches must have the same lgK and seed.
   *
   * # Arguments
   * * `other` - Another ThetaSketch
   *
   * # Returns
   * New ThetaSketch with union result
   *
   * # Throws
   * - If sketches have different lgK or seed
   *
   * # Example
   * ```javascript
   * const union = sketchA.union(sketchB);
   * console.log(union.estimate()); // |A ∪ B|
   * ```
   */
  union(other: ThetaSketch): ThetaSketch
  /**
   * Compute intersection with another sketch: |A ∩ B|
   *
   * Returns a new sketch representing items in both A and B.
   * Both sketches must have the same lgK and seed.
   *
   * # Arguments
   * * `other` - Another ThetaSketch
   *
   * # Returns
   * New ThetaSketch with intersection result
   *
   * # Throws
   * - If sketches have different lgK or seed
   *
   * # Example
   * ```javascript
   * const intersection = sketchA.intersect(sketchB);
   * console.log(intersection.estimate()); // |A ∩ B|
   * ```
   */
  intersect(other: ThetaSketch): ThetaSketch
  /**
   * Compute difference: |A - B| (items in A but not in B)
   *
   * Returns a new sketch representing items in A that are not in B.
   * Both sketches must have the same lgK and seed.
   * Note: A - B != B - A (not commutative)
   *
   * # Arguments
   * * `other` - Another ThetaSketch
   *
   * # Returns
   * New ThetaSketch with difference result
   *
   * # Throws
   * - If sketches have different lgK or seed
   *
   * # Example
   * ```javascript
   * const difference = sketchA.difference(sketchB);
   * console.log(difference.estimate()); // |A - B|
   * ```
   */
  difference(other: ThetaSketch): ThetaSketch
  /**
   * Compute Jaccard similarity: |A ∩ B| / |A ∪ B|
   *
   * Returns the Jaccard similarity coefficient between two sets,
   * a value between 0 (no overlap) and 1 (identical sets).
   *
   * # Arguments
   * * `other` - Another ThetaSketch
   *
   * # Returns
   * Jaccard similarity coefficient (0.0 to 1.0)
   *
   * # Throws
   * - If sketches have different lgK or seed
   *
   * # Example
   * ```javascript
   * const similarity = sketchA.jaccardSimilarity(sketchB);
   * console.log(`Similarity: ${(similarity * 100).toFixed(1)}%`);
   * ```
   */
  jaccardSimilarity(other: ThetaSketch): number
  /**
   * Get string representation
   *
   * # Example
   * ```javascript
   * console.log(theta.toString());
   * // "ThetaSketch(capacity=4096, retained=1000, estimate=1000)"
   * ```
   */
  toString(): string
}
/**
 * Count-Min Sketch for frequency estimation
 *
 * A space-efficient probabilistic data structure for estimating item frequencies
 * in a data stream. The sketch guarantees:
 * - Never underestimates (always returns count >= true count)
 * - Error bounded by epsilon*N with probability 1-delta (where N is total stream size)
 *
 * # Example
 * ```javascript
 * const { CountMinSketch } = require('@sketch-oxide/node');
 * const cms = new CountMinSketch(0.01, 0.01);
 * cms.update(Buffer.from('apple'));
 * cms.update(Buffer.from('apple'));
 * cms.update(Buffer.from('banana'));
 * console.log(cms.estimate(Buffer.from('apple'))); // ~2
 * ```
 */
export declare class CountMinSketch {
  /**
   * Create a new Count-Min Sketch with specified error bounds
   *
   * # Arguments
   * * `epsilon` - Error bound (0 < epsilon < 1): estimates are within epsilon*N of true value
   * * `delta` - Failure probability (0 < delta < 1): guarantee holds with probability 1-delta
   *
   * # Returns
   * A new CountMinSketch instance
   *
   * # Throws
   * - If epsilon is not in (0, 1)
   * - If delta is not in (0, 1)
   *
   * # Example
   * ```javascript
   * // 1% error bound, 1% failure probability
   * const cms = new CountMinSketch(0.01, 0.01);
   * ```
   */
  constructor(epsilon: number, delta: number)
  /** Add an item to the sketch (increment count by 1) */
  update(item: Buffer): void
  /** Estimate the frequency of an item */
  estimate(item: Buffer): number
  /** Merge another Count-Min Sketch into this one */
  merge(other: CountMinSketch): void
  /** Get the width of the sketch */
  width(): number
  /** Get the depth of the sketch */
  depth(): number
  /** Get the epsilon parameter */
  epsilon(): number
  /** Get the delta parameter */
  delta(): number
  /** Serialize the sketch to binary format */
  serialize(): Buffer
  /** Deserialize from binary format */
  static deserialize(data: Buffer): CountMinSketch
  /** Get string representation */
  toString(): string
}
/**
 * Count Sketch for unbiased frequency estimation
 *
 * Unlike Count-Min Sketch, Count Sketch:
 * - Can estimate both positive and negative frequencies (supports deletions)
 * - Has E[estimate] = true_count (unbiased)
 * - Provides L2 error guarantees
 *
 * # Example
 * ```javascript
 * const { CountSketch } = require('@sketch-oxide/node');
 * const cs = new CountSketch(0.1, 0.01);
 * cs.update(Buffer.from('apple'), 5);
 * cs.update(Buffer.from('apple'), -2);  // Decrement by 2
 * console.log(cs.estimate(Buffer.from('apple'))); // ~3
 * ```
 */
export declare class CountSketch {
  /** Create a new Count Sketch with specified error bounds */
  constructor(epsilon: number, delta: number)
  /** Update the sketch with an item and delta */
  update(item: Buffer, delta: number): void
  /** Estimate the frequency of an item */
  estimate(item: Buffer): number
  /** Estimate inner product of two frequency vectors */
  innerProduct(other: CountSketch): number
  /** Merge another Count Sketch into this one */
  merge(other: CountSketch): void
  width(): number
  depth(): number
  epsilon(): number
  delta(): number
  serialize(): Buffer
  static deserialize(data: Buffer): CountSketch
  toString(): string
}
/**
 * Conservative Update Count-Min Sketch for improved frequency estimation
 *
 * More accurate than standard Count-Min (up to 10x less overestimation)
 * but does NOT support deletions.
 */
export declare class ConservativeCountMin {
  constructor(epsilon: number, delta: number)
  static withDimensions(width: number, depth: number): ConservativeCountMin
  update(item: Buffer): void
  updateCount(item: Buffer, count: number): void
  estimate(item: Buffer): number
  merge(other: ConservativeCountMin): void
  width(): number
  depth(): number
  epsilon(): number
  delta(): number
  totalCount(): number
  memoryUsage(): number
  clear(): void
  serialize(): Buffer
  static deserialize(data: Buffer): ConservativeCountMin
  toString(): string
}
/**
 * Space-Saving Sketch for Heavy Hitters Detection
 *
 * Finds the most frequent items with guaranteed no false negatives.
 */
export declare class SpaceSaving {
  constructor(epsilon: number)
  static withCapacity(capacity: number): SpaceSaving
  update(item: Buffer): void
  estimate(item: Buffer): HeavyHitterResult | null
  heavyHitters(threshold: number): Array<HeavyHitterResult>
  topK(k: number): Array<HeavyHitterResult>
  merge(other: SpaceSaving): void
  capacity(): number
  streamLength(): number
  epsilon(): number
  numItems(): number
  isEmpty(): boolean
  maxError(): number
  toString(): string
}
/** Frequent Items sketch based on Misra-Gries algorithm */
export declare class FrequentItems {
  constructor(maxSize: number)
  update(item: Buffer): void
  updateBy(item: Buffer, count: number): void
  getEstimate(item: Buffer): FrequentItemResult | null
  frequentItems(errorType: FrequentItemsErrorType): Array<FrequentItemResult>
  merge(other: FrequentItems): void
  isEmpty(): boolean
  numItems(): number
  maxSize(): number
  offset(): number
  toString(): string
}
/**
 * Binary Fuse Filter for probabilistic membership testing
 *
 * State-of-the-art filter with ~75% better space efficiency than Bloom filters.
 * This is an immutable data structure - build from a complete set of items.
 */
export declare class BinaryFuseFilter {
  /** Create a Binary Fuse Filter from an array of BigInt items */
  static fromItems(items: Array<bigint>, bitsPerEntry: number): BinaryFuseFilter
  /** Check if an item might be in the set */
  contains(item: bigint): boolean
  len(): number
  isEmpty(): boolean
  bitsPerEntry(): number
  estimatedFpr(): number
  serialize(): Buffer
  static deserialize(data: Buffer): BinaryFuseFilter
  toString(): string
}
/**
 * Bloom Filter for probabilistic membership testing
 *
 * Classic probabilistic data structure supporting dynamic insertions.
 * Zero false negatives guaranteed.
 */
export declare class BloomFilter {
  constructor(n: number, fpr?: number | undefined | null)
  insert(key: Buffer): void
  contains(key: Buffer): boolean
  clear(): void
  mergeWith(other: BloomFilter): void
  isEmpty(): boolean
  len(): number
  falsePositiveRate(): number
  memoryUsage(): number
  serialize(): Buffer
  static deserialize(data: Buffer): BloomFilter
  toString(): string
}
/** Blocked Bloom Filter for cache-efficient membership testing */
export declare class BlockedBloomFilter {
  constructor(n: number, fpr?: number | undefined | null)
  insert(key: Buffer): void
  contains(key: Buffer): boolean
  clear(): void
  mergeWith(other: BlockedBloomFilter): void
  isEmpty(): boolean
  len(): number
  falsePositiveRate(): number
  memoryUsage(): number
  serialize(): Buffer
  static deserialize(data: Buffer): BlockedBloomFilter
  toString(): string
}
/** Counting Bloom Filter with deletion support */
export declare class CountingBloomFilter {
  constructor(n: number, fpr?: number | undefined | null)
  insert(key: Buffer): void
  remove(key: Buffer): boolean
  contains(key: Buffer): boolean
  countEstimate(key: Buffer): number
  clear(): void
  mergeWith(other: CountingBloomFilter): void
  isEmpty(): boolean
  len(): number
  hasOverflow(): boolean
  falsePositiveRate(): number
  memoryUsage(): number
  serialize(): Buffer
  static deserialize(data: Buffer): CountingBloomFilter
  toString(): string
}
/** Cuckoo Filter for membership testing with deletions */
export declare class CuckooFilter {
  constructor(capacity: number)
  insert(key: Buffer): void
  remove(key: Buffer): boolean
  contains(key: Buffer): boolean
  clear(): void
  isEmpty(): boolean
  len(): number
  capacity(): number
  loadFactor(): number
  memoryUsage(): number
  serialize(): Buffer
  static deserialize(data: Buffer): CuckooFilter
  toString(): string
}
/** Ribbon Filter for space-efficient membership testing */
export declare class RibbonFilter {
  constructor(n: number, fpr?: number | undefined | null)
  insert(key: Buffer): void
  build(): void
  contains(key: Buffer): boolean
  isFinalized(): boolean
  len(): number
  isEmpty(): boolean
  falsePositiveRate(): number
  memoryUsage(): number
  serialize(): Buffer
  static deserialize(data: Buffer): RibbonFilter
  toString(): string
}
/**
 * StableBloomFilter for membership testing with decay mechanism
 *
 * A Bloom filter variant that decays counts over time, useful for tracking
 * recently-seen items while removing old ones without explicit deletion.
 *
 * # Example
 * ```javascript
 * const { StableBloomFilter } = require('@sketch-oxide/node');
 * const sbf = new StableBloomFilter(1000, 0.01);
 * sbf.insert(Buffer.from('item1'));
 * console.log(sbf.contains(Buffer.from('item1'))); // true
 * ```
 */
export declare class StableBloomFilter {
  /**
   * Create a new StableBloomFilter
   *
   * # Arguments
   * * `expected_items` - Expected number of items to store
   * * `fpr` - Target false positive rate (0 < fpr < 1)
   */
  constructor(expectedItems: number, fpr?: number | undefined | null)
  /**
   * Insert a key into the filter
   *
   * # Arguments
   * * `key` - Binary data to insert
   */
  insert(key: Buffer): void
  /**
   * Check if a key might be in the set
   *
   * # Returns
   * True if key might be present, False if definitely not present
   */
  contains(key: Buffer): boolean
  /**
   * Get the count estimate for a key
   *
   * # Arguments
   * * `key` - Binary data to check
   *
   * # Returns
   * Counter value (0-255 depending on counter_bits)
   */
  getCount(key: Buffer): number
  /** Get the number of counters in this filter */
  numCounters(): number
  /** Get the number of hash functions used */
  numHashes(): number
  /** Get the number of decrements performed */
  decrementCount(): number
  /** Get the fill ratio of the filter (0.0 to 1.0) */
  fillRatio(): number
  /** Clear all data from the filter */
  clear(): void
  /** Get memory usage in bytes */
  memoryUsage(): number
  /** Serialize the filter to binary format */
  serialize(): Buffer
  /** Deserialize a filter from binary format */
  static deserialize(data: Buffer): StableBloomFilter
  /** Get a string representation */
  toString(): string
}
export { DdSketch as DDSketch }
/** DDSketch for quantile estimation with relative error guarantees */
export declare class DdSketch {
  constructor(relativeAccuracy: number)
  update(value: number): void
  updateBatch(values: Array<number>): void
  quantile(q: number): number | null
  quantiles(quantiles: Array<number>): Array<number>
  mergeWith(other: DdSketch): void
  count(): number
  min(): number | null
  max(): number | null
  isEmpty(): boolean
  serialize(): Buffer
  static deserialize(data: Buffer): DdSketch
  toString(): string
}
/** REQ Sketch for streaming quantile estimation (PODS 2021) */
export declare class ReqSketch {
  constructor(k: number, mode: ReqSketchMode)
  update(value: number): void
  updateBatch(values: Array<number>): void
  quantile(q: number): number | null
  quantiles(quantiles: Array<number>): Array<number>
  mergeWith(other: ReqSketch): ReqSketch
  count(): number
  min(): number | null
  max(): number | null
  isEmpty(): boolean
  toString(): string
}
/** T-Digest for quantile estimation with tail accuracy */
export declare class TDigest {
  constructor(compression?: number | undefined | null)
  update(value: number): void
  updateBatch(values: Array<number>): void
  quantile(q: number): number
  quantiles(quantiles: Array<number>): Array<number>
  cdf(value: number): number
  trimmedMean(low: number, high: number): number
  mergeWith(other: TDigest): void
  count(): number
  compression(): number
  centroidCount(): number
  min(): number
  max(): number
  isEmpty(): boolean
  serialize(): Buffer
  static deserialize(data: Buffer): TDigest
  toString(): string
}
/** KLL Sketch for quantile estimation (Karnin 2016) */
export declare class KllSketch {
  constructor(k?: number | undefined | null)
  update(value: number): void
  updateBatch(values: Array<number>): void
  quantile(rank: number): number | null
  quantiles(ranks: Array<number>): Array<number>
  rank(value: number): number
  mergeWith(other: KllSketch): void
  k(): number
  count(): number
  min(): number
  max(): number
  normalizedRankError(): number
  numRetained(): number
  isEmpty(): boolean
  serialize(): Buffer
  static deserialize(data: Buffer): KllSketch
  toString(): string
}
/**
 * SplineSketch for quantile estimation
 *
 * A space-efficient sketch for estimating quantiles of a data stream.
 * Uses spline-based interpolation for smooth quantile estimates.
 *
 * # Example
 * ```javascript
 * const { SplineSketch } = require('@sketch-oxide/node');
 * const sketch = new SplineSketch(256);
 * for (let i = 1; i <= 1000; i++) {
 *   sketch.insert(i, 1.0);
 * }
 * console.log(sketch.query(0.5)); // ~500
 * ```
 */
export declare class SplineSketch {
  /**
   * Create a new SplineSketch
   *
   * # Arguments
   * * `max_samples` - Maximum number of samples to retain
   */
  constructor(maxSamples?: number | undefined | null)
  /**
   * Add a value to the sketch
   *
   * # Arguments
   * * `value` - The value to add
   * * `weight` - The weight of the value (default 1.0)
   */
  insert(value: number, weight?: number | undefined | null): void
  /**
   * Query a quantile value
   *
   * # Arguments
   * * `quantile` - The quantile to query (0.0 to 1.0)
   *
   * # Returns
   * The estimated value at that quantile
   */
  query(quantile: number): number
  /** Get the minimum value seen */
  min(): number | null
  /** Get the maximum value seen */
  max(): number | null
  /** Get the number of samples retained */
  sampleCount(): number
  /** Get the maximum number of samples */
  maxSamples(): number
  /** Get the total weight of all values */
  totalWeight(): number
  /**
   * Merge another SplineSketch into this one
   *
   * # Arguments
   * * `other` - Another SplineSketch to merge
   */
  mergeWith(other: SplineSketch): void
  /** Reset the sketch to empty state */
  reset(): void
  /** Get a string representation */
  toString(): string
}
/**
 * MinHash sketch for Jaccard similarity estimation
 *
 * Approximates the Jaccard similarity |A ∩ B| / |A ∪ B| using k hash functions.
 * Standard error is approximately 1/sqrt(k).
 */
export declare class MinHash {
  /** Create a new MinHash sketch with specified number of permutations */
  constructor(numPerm: number)
  /** Add an item to the set */
  update(item: Buffer): void
  /** Estimate Jaccard similarity with another MinHash */
  jaccardSimilarity(other: MinHash): number
  /** Merge another MinHash (union operation) */
  merge(other: MinHash): void
  /** Get the number of permutations */
  numPerm(): number
  /** Check if empty */
  isEmpty(): boolean
  /** Serialize to binary format */
  serialize(): Buffer
  /** Deserialize from binary format */
  static deserialize(data: Buffer): MinHash
  /** Get string representation */
  toString(): string
}
/** SimHash sketch for near-duplicate detection */
export declare class SimHash {
  /** Create a new SimHash sketch */
  constructor()
  /** Add a feature to the sketch */
  update(feature: Buffer): void
  /** Add a weighted feature */
  updateWeighted(feature: Buffer, weight: number): void
  /** Get the 64-bit fingerprint */
  fingerprint(): bigint
  /** Compute Hamming distance to another SimHash (0-64) */
  hammingDistance(other: SimHash): number
  /** Compute similarity as (64 - hammingDistance) / 64 */
  similarity(other: SimHash): number
  /** Get number of features added */
  len(): number
  /** Check if empty */
  isEmpty(): boolean
  /** Merge another SimHash */
  merge(other: SimHash): void
  /** Serialize to binary format */
  serialize(): Buffer
  /** Deserialize from binary format */
  static deserialize(data: Buffer): SimHash
  /** Get string representation */
  toString(): string
}
/** Reservoir Sampling for uniform random samples from streams */
export declare class ReservoirSampling {
  /** Create a new Reservoir Sampling instance */
  constructor(k: number)
  /** Create with seed for reproducibility */
  static withSeed(k: number, seed: bigint): ReservoirSampling
  /** Add an item to the stream */
  update(item: Buffer): void
  /** Get the current sample */
  sample(): Array<Buffer>
  /** Check if empty */
  isEmpty(): boolean
  /** Get current sample size */
  len(): number
  /** Get maximum capacity */
  capacity(): number
  /** Get total items seen */
  count(): bigint
  /** Get inclusion probability */
  inclusionProbability(): number
  /** Clear the reservoir */
  clear(): void
  /** Merge another reservoir sample */
  merge(other: ReservoirSampling): void
  /** Get string representation */
  toString(): string
}
/** VarOpt Sampling for variance-optimal weighted samples */
export declare class VarOptSampling {
  /** Create a new VarOpt Sampling instance */
  constructor(k: number)
  /** Create with seed for reproducibility */
  static withSeed(k: number, seed: bigint): VarOptSampling
  /** Add a weighted item */
  update(item: Buffer, weight: number): void
  /** Get the current sample */
  sample(): Array<WeightedSampleItem>
  /** Check if empty */
  isEmpty(): boolean
  /** Get current sample size */
  len(): number
  /** Get maximum capacity */
  capacity(): number
  /** Get total items seen */
  count(): bigint
  /** Get current threshold */
  threshold(): number
  /** Get total weight in sample */
  totalWeight(): number
  /** Estimate total weight of stream */
  estimateTotalWeight(): number
  /** Clear the sampler */
  clear(): void
  /** Merge another VarOpt sample */
  merge(other: VarOptSampling): void
  /** Get string representation */
  toString(): string
}
/** Sliding Window Counter using Exponential Histogram */
export declare class SlidingWindowCounter {
  /** Create a new Sliding Window Counter */
  constructor(windowSize: bigint, epsilon: number)
  /** Increment at given timestamp */
  increment(timestamp: bigint): void
  /** Increment by amount at given timestamp */
  incrementBy(timestamp: bigint, count: bigint): void
  /** Get count within window ending at given time */
  count(currentTime: bigint): bigint
  /** Get count for specific range */
  countRange(start: bigint, end: bigint): bigint
  /** Expire old buckets */
  expire(currentTime: bigint): void
  /** Clear all buckets */
  clear(): void
  /** Get window size */
  windowSize(): bigint
  /** Get error bound */
  epsilon(): number
  /** Get number of buckets */
  numBuckets(): number
  /** Get theoretical error bound */
  errorBound(): number
  /** Get memory usage in bytes */
  memoryUsage(): number
  /** Serialize to binary format */
  serialize(): Buffer
  /** Deserialize from binary format */
  static deserialize(data: Buffer): SlidingWindowCounter
  /** Get string representation */
  toString(): string
}
/** Exponential Histogram with formal error bounds */
export declare class ExponentialHistogram {
  /** Create a new Exponential Histogram */
  constructor(windowSize: bigint, epsilon: number)
  /** Insert an event at timestamp with count */
  insert(timestamp: bigint, count: bigint): void
  /** Get count estimate with bounds */
  count(currentTime: bigint): CountWithBounds
  /** Expire old buckets */
  expire(currentTime: bigint): void
  /** Clear all buckets */
  clear(): void
  /** Get window size */
  windowSize(): bigint
  /** Get error bound */
  epsilon(): number
  /** Get k value */
  k(): number
  /** Get number of buckets */
  numBuckets(): number
  /** Get theoretical error bound */
  errorBound(): number
  /** Get memory usage in bytes */
  memoryUsage(): number
  /** Check if empty */
  isEmpty(): boolean
  /** Merge another ExponentialHistogram */
  merge(other: ExponentialHistogram): void
  /** Serialize to binary format */
  serialize(): Buffer
  /** Deserialize from binary format */
  static deserialize(data: Buffer): ExponentialHistogram
  /** Get string representation */
  toString(): string
}
/** Elastic Sketch for frequency estimation */
export declare class ElasticSketch {
  /** Create a new Elastic Sketch with default elastic ratio (0.2) */
  constructor(bucketCount: number, depth: number)
  /** Create with custom elastic ratio */
  static withElasticRatio(bucketCount: number, depth: number, elasticRatio: number): ElasticSketch
  /** Update with item and count */
  update(item: Buffer, count: bigint): void
  /** Estimate frequency of an item */
  estimate(item: Buffer): bigint
  /** Find heavy hitters with frequency >= threshold */
  heavyHitters(threshold: bigint): Array<HeavyHitter>
  /** Reset the sketch */
  reset(): void
  /** Get bucket count */
  bucketCount(): number
  /** Get depth */
  depth(): number
  /** Get elastic ratio */
  elasticRatio(): number
  /** Get total count */
  totalCount(): bigint
  /** Check if empty */
  isEmpty(): boolean
  /** Get memory usage */
  memoryUsage(): number
  /** Merge another ElasticSketch */
  merge(other: ElasticSketch): void
  /** Serialize to binary format */
  serialize(): Buffer
  /** Deserialize from binary format */
  static deserialize(data: Buffer): ElasticSketch
  /** Get string representation */
  toString(): string
}
export { Salsa as SALSA }
/** SALSA: Self-Adjusting Counter Sizing for frequency estimation */
export declare class Salsa {
  /** Create a new SALSA sketch */
  constructor(epsilon: number, delta: number)
  /** Update with item and frequency */
  update(item: Buffer, count: bigint): void
  /** Estimate frequency with confidence */
  estimate(item: Buffer): EstimateWithConfidence
  /** Get epsilon parameter */
  epsilon(): number
  /** Get delta parameter */
  delta(): number
  /** Get maximum frequency observed */
  maxObserved(): bigint
  /** Get total updates */
  totalUpdates(): bigint
  /** Get adaptation level */
  adaptationLevel(): number
  /** Get width */
  width(): number
  /** Get depth */
  depth(): number
  /** Merge another SALSA sketch */
  merge(other: Salsa): void
  /** Get string representation */
  toString(): string
}
/** Removable Universal Sketch for frequency estimation with deletions */
export declare class RemovableUniversalSketch {
  /** Create a new Removable Universal Sketch */
  constructor(epsilon: number, delta: number)
  /** Update with signed frequency (positive for insert, negative for delete) */
  update(item: Buffer, delta: number): void
  /** Estimate frequency */
  estimate(item: Buffer): number
  /** Compute L2 norm of frequency vector */
  l2Norm(): number
  /** Get epsilon parameter */
  epsilon(): number
  /** Get delta parameter */
  delta(): number
  /** Get width */
  width(): number
  /** Get depth */
  depth(): number
  /** Merge another RemovableUniversalSketch */
  merge(other: RemovableUniversalSketch): void
  /** Get string representation */
  toString(): string
}
/**
 * HeavyKeeper - Top-k heavy hitter detection with exponential decay
 *
 * Identifies the most frequent items in a data stream with high precision.
 * Uses exponential decay to actively remove small flows while protecting heavy hitters.
 *
 * # Example
 * ```javascript
 * const { HeavyKeeper } = require('@sketch-oxide/node');
 * const hk = new HeavyKeeper(100, 0.001, 0.01);
 *
 * // Update with items
 * for (let i = 0; i < 1000; i++) {
 *     hk.update(Buffer.from('frequent_item'));
 * }
 * for (let i = 0; i < 10; i++) {
 *     hk.update(Buffer.from('rare_item'));
 * }
 *
 * // Get top-k heavy hitters
 * const topK = hk.topK();
 * console.log(topK); // [{hash: ..., count: ...}, ...]
 *
 * // Estimate specific item
 * const count = hk.estimate(Buffer.from('frequent_item'));
 * console.log(count); // ~1000
 * ```
 */
export declare class HeavyKeeper {
  /**
   * Create a new HeavyKeeper sketch
   *
   * # Arguments
   * * `k` - Number of top items to track
   * * `epsilon` - Error bound (default: 0.001)
   * * `delta` - Failure probability (default: 0.01)
   *
   * # Throws
   * - If k is 0
   * - If epsilon or delta are out of range (0, 1)
   *
   * # Example
   * ```javascript
   * const hk = new HeavyKeeper(100, 0.001, 0.01);
   * ```
   */
  constructor(k: number, epsilon?: number | undefined | null, delta?: number | undefined | null)
  /**
   * Add an item to the sketch
   *
   * # Arguments
   * * `item` - Binary data to track
   *
   * # Example
   * ```javascript
   * hk.update(Buffer.from('item1'));
   * hk.update(Buffer.from('frequent_item'));
   * ```
   */
  update(item: Buffer): void
  /**
   * Estimate the frequency of an item
   *
   * # Arguments
   * * `item` - Binary data to query
   *
   * # Returns
   * Estimated count (may overestimate, never underestimates)
   *
   * # Example
   * ```javascript
   * const count = hk.estimate(Buffer.from('item1'));
   * console.log(count); // e.g., 100
   * ```
   */
  estimate(item: Buffer): number
  /**
   * Get the top-k heavy hitters
   *
   * # Returns
   * Array of {hash, count} objects sorted by count descending
   *
   * # Example
   * ```javascript
   * const topK = hk.topK();
   * for (const item of topK) {
   *     console.log(`Hash: ${item.hash}, Count: ${item.count}`);
   * }
   * ```
   */
  topK(): Array<HeavyKeeperResult>
  /**
   * Apply exponential decay to all counters
   *
   * Ages old items to make room for new heavy hitters.
   *
   * # Example
   * ```javascript
   * hk.decay(); // Apply decay
   * ```
   */
  decay(): void
  /** Get string representation */
  toString(): string
}
export { RatelessIblt as RatelessIBLT }
/**
 * RatelessIBLT - Efficient set reconciliation for distributed systems
 *
 * Computes the symmetric difference between two sets without knowing
 * the difference size a priori. Used in blockchain, P2P networks, and
 * distributed databases.
 *
 * # Example
 * ```javascript
 * const { RatelessIBLT } = require('@sketch-oxide/node');
 *
 * // Create IBLTs for Alice and Bob
 * const alice = new RatelessIBLT(100, 32);
 * const bob = new RatelessIBLT(100, 32);
 *
 * // Both insert shared items
 * alice.insert(Buffer.from('shared1'), Buffer.from('value1'));
 * bob.insert(Buffer.from('shared1'), Buffer.from('value1'));
 *
 * // Alice has unique items
 * alice.insert(Buffer.from('alice_only'), Buffer.from('alice_value'));
 *
 * // Bob has unique items
 * bob.insert(Buffer.from('bob_only'), Buffer.from('bob_value'));
 *
 * // Compute difference
 * const diff = alice.clone();
 * diff.subtract(bob);
 *
 * // Decode to recover items
 * const result = diff.decode();
 * console.log(result.toInsert); // Items in Alice but not Bob
 * console.log(result.toRemove); // Items in Bob but not Alice
 * ```
 */
export declare class RatelessIblt {
  /**
   * Create a new RatelessIBLT
   *
   * # Arguments
   * * `expectedDiff` - Expected size of symmetric difference
   * * `cellSize` - Maximum size for cell data in bytes (typically 32-128)
   *
   * # Throws
   * - If expectedDiff is 0
   * - If cellSize is 0
   *
   * # Example
   * ```javascript
   * const iblt = new RatelessIBLT(100, 32);
   * ```
   */
  constructor(expectedDiff: number, cellSize: number)
  /**
   * Insert a key-value pair
   *
   * # Arguments
   * * `key` - Key to insert
   * * `value` - Value to insert
   *
   * # Example
   * ```javascript
   * iblt.insert(Buffer.from('key1'), Buffer.from('value1'));
   * ```
   */
  insert(key: Buffer, value: Buffer): void
  /**
   * Delete a key-value pair
   *
   * # Arguments
   * * `key` - Key to delete
   * * `value` - Value to delete
   *
   * # Example
   * ```javascript
   * iblt.delete(Buffer.from('key1'), Buffer.from('value1'));
   * ```
   */
  delete(key: Buffer, value: Buffer): void
  /**
   * Subtract another IBLT to compute symmetric difference
   *
   * # Arguments
   * * `other` - Another RatelessIBLT to subtract
   *
   * # Throws
   * - If IBLTs have incompatible parameters
   *
   * # Example
   * ```javascript
   * const diff = alice.clone();
   * diff.subtract(bob);
   * ```
   */
  subtract(other: RatelessIblt): void
  /**
   * Decode the IBLT to recover items
   *
   * # Returns
   * Object with toInsert, toRemove arrays and success flag
   *
   * # Example
   * ```javascript
   * const result = iblt.decode();
   * if (result.success) {
   *     console.log('Recovered difference successfully');
   *     console.log('To insert:', result.toInsert);
   *     console.log('To remove:', result.toRemove);
   * }
   * ```
   */
  decode(): IbltDecodeResult
  /** Get string representation */
  toString(): string
}
/**
 * Grafite - Optimal range filter with adversarial-robust guarantees
 *
 * The first optimal range filter providing provable FPR bounds of
 * L / 2^(B-2) where L is range width and B is bits per key.
 *
 * # Example
 * ```javascript
 * const { Grafite } = require('@sketch-oxide/node');
 *
 * // Build from sorted keys
 * const keys = [10n, 20n, 30n, 40n, 50n];
 * const filter = Grafite.build(keys, 6);
 *
 * // Query ranges
 * console.log(filter.mayContainRange(15n, 25n)); // true (contains 20)
 * console.log(filter.mayContain(30n)); // true (exact match)
 *
 * // Check FPR
 * const fpr = filter.expectedFpr(10n);
 * console.log(`Expected FPR: ${fpr}`); // 10 / 2^4 = 0.625
 * ```
 */
export declare class Grafite {
  /**
   * Build a Grafite filter from sorted keys
   *
   * # Arguments
   * * `keys` - Sorted array of 64-bit unsigned integers
   * * `bitsPerKey` - Number of bits per key (typically 4-8)
   *
   * # Throws
   * - If keys array is empty
   * - If bitsPerKey is out of range (2-16)
   *
   * # Example
   * ```javascript
   * const keys = [100n, 200n, 300n, 400n, 500n];
   * const filter = Grafite.build(keys, 6);
   * ```
   */
  static build(keys: Array<bigint>, bitsPerKey: number): Grafite
  /**
   * Check if a range may contain keys
   *
   * # Arguments
   * * `low` - Lower bound (inclusive)
   * * `high` - Upper bound (inclusive)
   *
   * # Returns
   * true if range may contain keys, false if definitely does not
   *
   * # Example
   * ```javascript
   * const mayContain = filter.mayContainRange(150n, 250n);
   * ```
   */
  mayContainRange(low: bigint, high: bigint): boolean
  /**
   * Check if a specific key may be present
   *
   * # Arguments
   * * `key` - Key to check
   *
   * # Returns
   * true if key may be present, false if definitely not
   *
   * # Example
   * ```javascript
   * const mayContain = filter.mayContain(200n);
   * ```
   */
  mayContain(key: bigint): boolean
  /**
   * Calculate expected false positive rate for a range width
   *
   * # Arguments
   * * `rangeWidth` - Width of the query range
   *
   * # Returns
   * Expected FPR = rangeWidth / 2^(bitsPerKey - 2)
   *
   * # Example
   * ```javascript
   * const fpr = filter.expectedFpr(100n);
   * console.log(`FPR: ${fpr}`);
   * ```
   */
  expectedFpr(rangeWidth: bigint): number
  /**
   * Get filter statistics
   *
   * # Returns
   * Object with keyCount, bitsPerKey, totalBits
   *
   * # Example
   * ```javascript
   * const stats = filter.stats();
   * console.log(`Keys: ${stats.keyCount}, Bits/key: ${stats.bitsPerKey}`);
   * ```
   */
  stats(): GrafiteStats
  /** Get string representation */
  toString(): string
}
/**
 * MementoFilter - Dynamic range filter with FPR guarantees
 *
 * The first dynamic range filter supporting insertions while maintaining
 * false positive rate guarantees. Combines a base range filter with a
 * quotient filter layer for precise element storage.
 *
 * # Example
 * ```javascript
 * const { MementoFilter } = require('@sketch-oxide/node');
 *
 * const filter = new MementoFilter(1000, 0.01);
 *
 * // Insert key-value pairs dynamically
 * filter.insert(42n, Buffer.from('value1'));
 * filter.insert(100n, Buffer.from('value2'));
 * filter.insert(250n, Buffer.from('value3'));
 *
 * // Query ranges
 * console.log(filter.mayContainRange(40n, 50n)); // true
 * console.log(filter.mayContainRange(500n, 600n)); // likely false
 * ```
 */
export declare class MementoFilter {
  /**
   * Create a new MementoFilter
   *
   * # Arguments
   * * `expectedElements` - Expected number of elements
   * * `fpr` - Target false positive rate (0 < fpr < 1)
   *
   * # Throws
   * - If expectedElements is 0
   * - If fpr is out of range (0, 1)
   *
   * # Example
   * ```javascript
   * const filter = new MementoFilter(1000, 0.01); // 1% FPR
   * ```
   */
  constructor(expectedElements: number, fpr: number)
  /**
   * Insert a key-value pair
   *
   * # Arguments
   * * `key` - 64-bit unsigned integer key
   * * `value` - Value as binary data
   *
   * # Example
   * ```javascript
   * filter.insert(42n, Buffer.from('value1'));
   * filter.insert(100n, Buffer.from('value2'));
   * ```
   */
  insert(key: bigint, value: Buffer): void
  /**
   * Check if a range may contain keys
   *
   * # Arguments
   * * `low` - Lower bound (inclusive)
   * * `high` - Upper bound (inclusive)
   *
   * # Returns
   * true if range may contain keys, false if definitely does not
   *
   * # Example
   * ```javascript
   * const mayContain = filter.mayContainRange(40n, 50n);
   * ```
   */
  mayContainRange(low: bigint, high: bigint): boolean
  /** Get string representation */
  toString(): string
}
/**
 * SlidingHyperLogLog - Time-windowed cardinality estimation
 *
 * Extends HyperLogLog with temporal awareness for cardinality estimation
 * over sliding time windows. Essential for real-time analytics, DDoS detection,
 * and streaming applications.
 *
 * # Example
 * ```javascript
 * const { SlidingHyperLogLog } = require('@sketch-oxide/node');
 *
 * // Create with precision 12, 1-hour max window
 * const hll = new SlidingHyperLogLog(12, 3600);
 *
 * // Add items with timestamps
 * hll.update(Buffer.from('user_123'), 1000);
 * hll.update(Buffer.from('user_456'), 1030);
 * hll.update(Buffer.from('user_789'), 1060);
 *
 * // Estimate cardinality in last 60 seconds
 * const estimate = hll.estimateWindow(1060, 60);
 * console.log(`Unique items in window: ${Math.round(estimate)}`);
 *
 * // Decay old entries
 * hll.decay(2000, 600);
 * ```
 */
export declare class SlidingHyperLogLog {
  /**
   * Create a new SlidingHyperLogLog
   *
   * # Arguments
   * * `precision` - Number of bits (4-16, typical 12-14)
   * * `maxWindowSeconds` - Maximum window size in seconds
   *
   * # Throws
   * - If precision is out of range (4-16)
   * - If maxWindowSeconds is 0
   *
   * # Example
   * ```javascript
   * const hll = new SlidingHyperLogLog(12, 3600); // 1-hour window
   * ```
   */
  constructor(precision: number, maxWindowSeconds: bigint)
  /**
   * Add an item with timestamp
   *
   * # Arguments
   * * `item` - Binary data to add
   * * `timestamp` - Unix timestamp in seconds
   *
   * # Example
   * ```javascript
   * hll.update(Buffer.from('user_id'), 1000);
   * hll.update(Buffer.from('event'), Date.now() / 1000);
   * ```
   */
  update(item: Buffer, timestamp: bigint): void
  /**
   * Estimate cardinality in a sliding window
   *
   * # Arguments
   * * `currentTime` - Current timestamp in seconds
   * * `windowSeconds` - Window size in seconds
   *
   * # Returns
   * Estimated number of unique items in [currentTime - windowSeconds, currentTime]
   *
   * # Example
   * ```javascript
   * const now = Date.now() / 1000;
   * const estimate = hll.estimateWindow(now, 60); // Last 60 seconds
   * ```
   */
  estimateWindow(currentTime: bigint, windowSeconds: bigint): number
  /**
   * Estimate total cardinality (all time)
   *
   * # Returns
   * Estimated number of unique items ever seen
   *
   * # Example
   * ```javascript
   * const total = hll.estimateTotal();
   * console.log(`Total unique items: ${Math.round(total)}`);
   * ```
   */
  estimateTotal(): number
  /**
   * Remove expired entries outside the window
   *
   * # Arguments
   * * `currentTime` - Current timestamp in seconds
   * * `windowSeconds` - Window size in seconds
   *
   * # Example
   * ```javascript
   * const now = Date.now() / 1000;
   * hll.decay(now, 3600); // Keep last hour
   * ```
   */
  decay(currentTime: bigint, windowSeconds: bigint): void
  /** Get string representation */
  toString(): string
}
/**
 * VacuumFilter: Best-in-class dynamic membership filter
 *
 * Space-efficient filter supporting insertions AND deletions with
 * <15 bits/item at 1% FPR (better than Cuckoo and Counting Bloom).
 *
 * # Use Cases
 * - Dynamic set membership with deletions
 * - Cache tracking with eviction
 * - Database deduplication
 * - Security: malicious URL tracking
 *
 * # Examples
 * ```javascript
 * const { VacuumFilter } = require('@sketch-oxide/node');
 *
 * const filter = new VacuumFilter(1000, 0.01);
 * filter.insert(Buffer.from('key1'));
 * console.log(filter.contains(Buffer.from('key1'))); // true
 *
 * filter.delete(Buffer.from('key1'));
 * console.log(filter.contains(Buffer.from('key1'))); // false
 *
 * const stats = filter.stats();
 * console.log(`Load factor: ${stats.loadFactor.toFixed(2)}`);
 * ```
 */
export declare class VacuumFilter {
  /**
   * Create a new VacuumFilter
   *
   * # Arguments
   * * `capacity` - Expected number of elements
   * * `fpr` - Target false positive rate (0 < fpr < 1)
   *
   * # Throws
   * - If capacity is 0
   * - If fpr is out of range
   *
   * # Example
   * ```javascript
   * const filter = new VacuumFilter(1000, 0.01); // 1000 items, 1% FPR
   * ```
   */
  constructor(capacity: number, fpr: number)
  /**
   * Insert an element into the filter
   *
   * # Arguments
   * * `key` - The key to insert
   *
   * # Example
   * ```javascript
   * filter.insert(Buffer.from('hello'));
   * filter.insert(Buffer.from('world'));
   * ```
   */
  insert(key: Buffer): void
  /**
   * Check if an element might be in the filter
   *
   * # Arguments
   * * `key` - The key to check
   *
   * # Returns
   * `true` if might be present (with FPR probability of false positive),
   * `false` if definitely not present
   *
   * # Example
   * ```javascript
   * if (filter.contains(Buffer.from('hello'))) {
   *   console.log('Key might be present');
   * }
   * ```
   */
  contains(key: Buffer): boolean
  /**
   * Delete an element from the filter
   *
   * # Arguments
   * * `key` - The key to delete
   *
   * # Returns
   * `true` if element was found and removed, `false` otherwise
   *
   * # Example
   * ```javascript
   * const wasDeleted = filter.delete(Buffer.from('hello'));
   * console.log(`Deleted: ${wasDeleted}`);
   * ```
   */
  delete(key: Buffer): boolean
  /**
   * Get current load factor (0.0 to 1.0)
   *
   * # Example
   * ```javascript
   * const loadFactor = filter.loadFactor();
   * console.log(`Filter is ${(loadFactor * 100).toFixed(1)}% full`);
   * ```
   */
  loadFactor(): number
  /**
   * Get total capacity
   *
   * # Example
   * ```javascript
   * console.log(`Capacity: ${filter.capacity()}`);
   * ```
   */
  capacity(): number
  /**
   * Get number of items currently stored
   *
   * # Example
   * ```javascript
   * console.log(`Items: ${filter.len()}`);
   * ```
   */
  len(): number
  /**
   * Check if filter is empty
   *
   * # Example
   * ```javascript
   * if (filter.isEmpty()) {
   *   console.log('Filter is empty');
   * }
   * ```
   */
  isEmpty(): boolean
  /**
   * Get memory usage in bytes
   *
   * # Example
   * ```javascript
   * console.log(`Memory: ${filter.memoryUsage()} bytes`);
   * ```
   */
  memoryUsage(): number
  /**
   * Get filter statistics
   *
   * # Returns
   * Object with capacity, numItems, loadFactor, memoryBits, fingerprintBits
   *
   * # Example
   * ```javascript
   * const stats = filter.stats();
   * console.log(`Load: ${stats.loadFactor.toFixed(2)}`);
   * console.log(`Memory: ${stats.memoryBits} bits`);
   * ```
   */
  stats(): VacuumFilterStats
  /**
   * Clear all items from the filter
   *
   * # Example
   * ```javascript
   * filter.clear();
   * console.log(filter.isEmpty()); // true
   * ```
   */
  clear(): void
  /** Get string representation */
  toString(): string
}
export { Grf as GRF }
/**
 * GRF (Gorilla Range Filter): Shape-based range filter for LSM-trees
 *
 * Advanced range filter optimized for skewed distributions.
 * Uses shape encoding for 30-50% better FPR than Grafite on real data.
 *
 * # Use Cases
 * - RocksDB/LevelDB SSTable filters
 * - Time-series databases (InfluxDB, TimescaleDB)
 * - Log aggregation systems
 * - Financial time-series data
 *
 * # Examples
 * ```javascript
 * const { GRF } = require('@sketch-oxide/node');
 *
 * // Build from Zipf-distributed keys
 * const keys = [1n, 2n, 3n, 5n, 8n, 13n, 21n];
 * const grf = GRF.build(keys, 6);
 *
 * console.log(grf.mayContainRange(10n, 25n)); // true (contains 13, 21)
 * console.log(grf.mayContain(13n)); // true
 *
 * const stats = grf.stats();
 * console.log(`Segments: ${stats.segmentCount}`);
 * ```
 */
export declare class Grf {
  /**
   * Build a GRF filter from sorted keys
   *
   * # Arguments
   * * `keys` - Array of sorted 64-bit unsigned integers
   * * `bitsPerKey` - Number of bits per key (2-16, typical 4-8)
   *
   * # Throws
   * - If keys array is empty
   * - If bitsPerKey is out of range
   *
   * # Example
   * ```javascript
   * const keys = [10n, 20n, 30n, 40n, 50n];
   * const grf = GRF.build(keys, 6);
   * ```
   */
  static build(keys: Array<bigint>, bitsPerKey: number): Grf
  /**
   * Check if a range may contain keys
   *
   * # Arguments
   * * `low` - Lower bound (inclusive)
   * * `high` - Upper bound (inclusive)
   *
   * # Returns
   * `true` if range might contain keys, `false` if definitely does not
   *
   * # Example
   * ```javascript
   * if (grf.mayContainRange(15n, 25n)) {
   *   console.log('Range might have keys');
   * }
   * ```
   */
  mayContainRange(low: bigint, high: bigint): boolean
  /**
   * Check if a specific key may be present
   *
   * # Arguments
   * * `key` - Key to check
   *
   * # Returns
   * `true` if key might be present, `false` if definitely not
   *
   * # Example
   * ```javascript
   * if (grf.mayContain(30n)) {
   *   console.log('Key might be present');
   * }
   * ```
   */
  mayContain(key: bigint): boolean
  /**
   * Calculate expected FPR for a range width
   *
   * # Arguments
   * * `rangeWidth` - Width of the query range
   *
   * # Returns
   * Expected false positive rate (0.0 to 1.0)
   *
   * # Example
   * ```javascript
   * const fpr = grf.expectedFpr(10n);
   * console.log(`Expected FPR: ${(fpr * 100).toFixed(2)}%`);
   * ```
   */
  expectedFpr(rangeWidth: bigint): number
  /**
   * Get filter statistics
   *
   * # Returns
   * Object with keyCount, segmentCount, avgKeysPerSegment, bitsPerKey, totalBits, memoryBytes
   *
   * # Example
   * ```javascript
   * const stats = grf.stats();
   * console.log(`Keys: ${stats.keyCount}, Segments: ${stats.segmentCount}`);
   * ```
   */
  stats(): GRFStats
  /** Get string representation */
  toString(): string
}
/**
 * NitroSketch: High-speed network telemetry with selective sampling
 *
 * Achieves 100Gbps line rate through probabilistic sampling while
 * maintaining accuracy via background synchronization.
 *
 * # Use Cases
 * - Network traffic monitoring at 100Gbps+
 * - DDoS detection
 * - Software-Defined Networking (SDN)
 * - Cloud telemetry
 * - Real-time analytics with CPU constraints
 *
 * # Examples
 * ```javascript
 * const { NitroSketch, CountMinSketch } = require('@sketch-oxide/node');
 *
 * const base = new CountMinSketch(0.01, 0.01);
 * const nitro = new NitroSketch(base, 0.1); // 10% sampling
 *
 * // High-speed updates
 * for (let i = 0; i < 100000; i++) {
 *   nitro.updateSampled(Buffer.from(`packet_${i % 100}`));
 * }
 *
 * // Synchronize for accuracy
 * nitro.sync(1.0);
 *
 * const stats = nitro.stats();
 * console.log(`Sampled: ${stats.sampledCount}, Total: ${stats.totalItemsEstimated}`);
 * ```
 */
export declare class NitroSketch {
  /**
   * Create a new NitroSketch wrapping a CountMinSketch
   *
   * # Arguments
   * * `baseSketch` - CountMinSketch to wrap
   * * `sampleRate` - Probability of updating (0 < rate <= 1)
   *   - 1.0 = update every item (no sampling)
   *   - 0.1 = update 10% of items
   *   - 0.01 = update 1% of items
   *
   * # Throws
   * - If sampleRate is out of range
   *
   * # Example
   * ```javascript
   * const base = new CountMinSketch(0.01, 0.01);
   * const nitro = new NitroSketch(base, 0.1);
   * ```
   */
  constructor(baseSketch: CountMinSketch, sampleRate: number)
  /**
   * Update with selective sampling
   *
   * Uses hash-based sampling to decide whether to update the base sketch.
   *
   * # Arguments
   * * `key` - The item to possibly add
   *
   * # Example
   * ```javascript
   * nitro.updateSampled(Buffer.from('flow_key'));
   * ```
   */
  updateSampled(key: Buffer): void
  /**
   * Query the frequency of a key
   *
   * For accurate results, call sync() periodically.
   *
   * # Arguments
   * * `key` - The item to query
   *
   * # Returns
   * Estimated frequency (may be underestimated if sync() not called)
   *
   * # Example
   * ```javascript
   * const freq = nitro.query(Buffer.from('key'));
   * console.log(`Frequency: ${freq}`);
   * ```
   */
  query(key: Buffer): number
  /**
   * Synchronize to adjust for unsampled items
   *
   * Background synchronization adjusts the sketch to account for
   * items that were not sampled, recovering accuracy.
   *
   * # Arguments
   * * `unsampledWeight` - Weight to apply to unsampled items (typically 1.0)
   *
   * # Example
   * ```javascript
   * nitro.sync(1.0); // Adjust for unsampled items
   * ```
   */
  sync(unsampledWeight: number): void
  /**
   * Get statistics about sampling
   *
   * # Returns
   * Object with sampleRate, sampledCount, unsampledCount, totalItemsEstimated
   *
   * # Example
   * ```javascript
   * const stats = nitro.stats();
   * console.log(`Sample rate: ${stats.sampleRate}`);
   * console.log(`Sampled: ${stats.sampledCount}`);
   * ```
   */
  stats(): NitroSketchStats
  /**
   * Reset sampling statistics
   *
   * # Example
   * ```javascript
   * nitro.resetStats();
   * ```
   */
  resetStats(): void
  /** Get string representation */
  toString(): string
}
/**
 * UnivMon: Universal sketch supporting multiple simultaneous metrics
 *
 * A single UnivMon estimates L1/L2 norms, entropy, heavy hitters,
 * and change detection, eliminating need for multiple specialized sketches.
 *
 * # Supported Metrics (from ONE sketch!)
 * 1. L1 Norm (sum of frequencies): Total traffic volume
 * 2. L2 Norm (sum of squared frequencies): Load balance
 * 3. Entropy (Shannon entropy): Distribution diversity
 * 4. Heavy Hitters: Most frequent items
 * 5. Change Detection: Temporal anomalies
 * 6. Flow Size Distribution: Per-flow statistics
 *
 * # Use Cases
 * - Network monitoring (simultaneous bandwidth, flows, protocols)
 * - Cloud analytics (unified telemetry)
 * - Real-time anomaly detection
 * - Multi-tenant systems
 *
 * # Examples
 * ```javascript
 * const { UnivMon } = require('@sketch-oxide/node');
 *
 * const univmon = new UnivMon(1000000, 0.01, 0.01);
 *
 * // Update with network packets
 * univmon.update(Buffer.from('192.168.1.1'), 1500);
 * univmon.update(Buffer.from('192.168.1.2'), 800);
 *
 * // Query multiple metrics from SAME sketch
 * console.log(`Total traffic: ${univmon.estimateL1()}`);
 * console.log(`Load balance: ${univmon.estimateL2()}`);
 * console.log(`IP diversity: ${univmon.estimateEntropy()}`);
 *
 * const topIPs = univmon.heavyHitters(0.1);
 * console.log(`Top IPs: ${topIPs.length}`);
 * ```
 */
export declare class UnivMon {
  /**
   * Create a new UnivMon sketch
   *
   * # Arguments
   * * `maxStreamSize` - Expected maximum number of items (determines layers)
   * * `epsilon` - Error parameter (0 < epsilon < 1)
   * * `delta` - Failure probability (0 < delta < 1)
   *
   * # Throws
   * - If maxStreamSize is 0
   * - If epsilon or delta are out of range
   *
   * # Example
   * ```javascript
   * const univmon = new UnivMon(1000000, 0.01, 0.01); // 1M items, 1% error
   * ```
   */
  constructor(maxStreamSize: number, epsilon: number, delta: number)
  /**
   * Update the sketch with an item and value
   *
   * # Arguments
   * * `item` - The item (e.g., IP address, user ID)
   * * `value` - The value/weight (e.g., packet size, transaction amount)
   *
   * # Example
   * ```javascript
   * univmon.update(Buffer.from('192.168.1.1'), 1500);
   * univmon.update(Buffer.from('user_123'), 99.99);
   * ```
   */
  update(item: Buffer, value: number): void
  /**
   * Estimate L1 norm (sum of frequencies)
   *
   * # Returns
   * Total sum of all values (e.g., total traffic volume)
   *
   * # Example
   * ```javascript
   * const totalTraffic = univmon.estimateL1();
   * console.log(`Total: ${totalTraffic} bytes`);
   * ```
   */
  estimateL1(): number
  /**
   * Estimate L2 norm (sum of squared frequencies)
   *
   * # Returns
   * L2 norm indicating distribution spread
   *
   * # Example
   * ```javascript
   * const l2 = univmon.estimateL2();
   * console.log(`Load balance metric: ${l2}`);
   * ```
   */
  estimateL2(): number
  /**
   * Estimate Shannon entropy
   *
   * # Returns
   * Entropy value indicating distribution diversity
   *
   * # Example
   * ```javascript
   * const entropy = univmon.estimateEntropy();
   * console.log(`Distribution diversity: ${entropy.toFixed(2)}`);
   * ```
   */
  estimateEntropy(): number
  /**
   * Get heavy hitters (most frequent items)
   *
   * # Arguments
   * * `threshold` - Frequency threshold (0 < threshold <= 1)
   *   - 0.1 = items with frequency >= 10% of total
   *
   * # Returns
   * Array of heavy hitter hashes
   *
   * # Example
   * ```javascript
   * const topItems = univmon.heavyHitters(0.1); // Top 10% items
   * console.log(`Found ${topItems.length} heavy hitters`);
   * ```
   */
  heavyHitters(threshold: number): Array<number>
  /**
   * Detect change between two UnivMon sketches
   *
   * # Arguments
   * * `other` - Another UnivMon sketch to compare
   *
   * # Returns
   * Change magnitude (higher = more change)
   *
   * # Example
   * ```javascript
   * const change = univmon1.detectChange(univmon2);
   * if (change > 0.5) {
   *   console.log('Significant distribution shift detected!');
   * }
   * ```
   */
  detectChange(other: UnivMon): number
  /** Get string representation */
  toString(): string
}
/**
 * LearnedBloomFilter: ML-enhanced membership testing
 *
 * **EXPERIMENTAL** - Uses machine learning to achieve 70-80% memory
 * reduction compared to standard Bloom filters.
 *
 * # WARNING
 * Do NOT use in security-critical applications. ML models can be
 * adversarially attacked to craft keys that fool the predictor.
 *
 * # Use Cases (Non-security)
 * - In-memory caches (memory optimization)
 * - Database query optimization
 * - Data deduplication
 * - Analytics systems
 *
 * # Examples
 * ```javascript
 * const { LearnedBloomFilter } = require('@sketch-oxide/node');
 *
 * // Train on dataset
 * const keys = [];
 * for (let i = 0; i < 10000; i++) {
 *   keys.push(Buffer.from(`key${i}`));
 * }
 *
 * const filter = LearnedBloomFilter.new(keys, 0.01);
 *
 * console.log(filter.contains(Buffer.from('key500'))); // true
 * console.log(filter.contains(Buffer.from('nonexistent'))); // probably false
 *
 * const mem = filter.memoryUsage();
 * console.log(`Memory: ${mem} bytes (70-80% reduction)`);
 * ```
 */
export declare class LearnedBloomFilter {
  /**
   * Create a new LearnedBloomFilter
   *
   * # Arguments
   * * `trainingKeys` - Keys to train on (must be members, at least 10 keys)
   * * `fpr` - Target false positive rate (0 < fpr < 1)
   *
   * # Throws
   * - If training data is empty or too small
   * - If fpr is out of range
   *
   * # Example
   * ```javascript
   * const keys = [];
   * for (let i = 0; i < 1000; i++) {
   *   keys.push(Buffer.from(`key${i}`));
   * }
   * const filter = LearnedBloomFilter.new(keys, 0.01);
   * ```
   */
  static new(trainingKeys: Array<Buffer>, fpr: number): LearnedBloomFilter
  /**
   * Check if a key might be in the set
   *
   * # Arguments
   * * `key` - The key to check
   *
   * # Returns
   * `true` if might be present (or false positive),
   * `false` if definitely not present
   *
   * # Guarantees
   * Zero false negatives: All training keys will return `true`
   *
   * # Example
   * ```javascript
   * if (filter.contains(Buffer.from('key1'))) {
   *   console.log('Key might be present');
   * }
   * ```
   */
  contains(key: Buffer): boolean
  /**
   * Get memory usage in bytes
   *
   * # Example
   * ```javascript
   * console.log(`Memory: ${filter.memoryUsage()} bytes`);
   * ```
   */
  memoryUsage(): number
  /** Get string representation */
  toString(): string
}
